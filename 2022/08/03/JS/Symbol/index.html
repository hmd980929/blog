

<!DOCTYPE html>
<html lang="zh-CN" >



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/tiger.ico">
  <link rel="icon" href="/blog/img/tiger.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9fa19d">
  <meta name="author" content="Colin">
  <meta name="keywords" content="">
  
    <meta name="description" content="Symbol概述ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。 ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 J">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript-Symbol">
<meta property="og:url" content="https://web.hanmingda.top.com/blog/2022/08/03/JS/Symbol/index.html">
<meta property="og:site_name" content="Colin&#39;s Blog">
<meta property="og:description" content="Symbol概述ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。 ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 J">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-03T05:59:11.888Z">
<meta property="article:modified_time" content="2022-08-03T06:03:06.622Z">
<meta property="article:author" content="Colin">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>JavaScript-Symbol - Colin&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/blog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/blog/css/highlight.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"web.hanmingda.top.com","root":"/blog/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"eopOTztyzVfS6A0wAoyT6Ygz-gzGzoHsz","app_key":"mT3xquiKA9CUtute8SzdIN1d","server_url":"https://eopotzty.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/blog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/blog/">
      <strong>Colin&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/blog/img/bg.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JavaScript-Symbol"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Colin
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-03 13:59" pubdate>
          2022年8月3日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          131 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JavaScript-Symbol</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。</p>
<p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p>Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-title class_">Symbol</span>();<br><br><span class="hljs-keyword">typeof</span> s <span class="hljs-comment">// &quot;symbol&quot; </span><br></code></pre></td></tr></table></figure>
<p>上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。</p>
<p>注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。<br>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;bar&#x27;</span>); <br><br>s1 <span class="hljs-comment">// Symbol(foo) </span><br>s2 <span class="hljs-comment">// Symbol(bar)  </span><br><br>s1.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &quot;Symbol(foo)&quot; </span><br>s2.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &quot;Symbol(bar)&quot; </span><br></code></pre></td></tr></table></figure>
<p>上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p>
<p>如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;abc&#x27;</span>;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> sym = <span class="hljs-title class_">Symbol</span>(obj);<br>sym <span class="hljs-comment">// Symbol(abc)</span><br></code></pre></td></tr></table></figure>
<p>注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 没有参数的情况</span><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>();<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>();<br><br>s1 === s2 <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 有参数的情况</span><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><br>s1 === s2 <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
<p>上面代码中，s1和s2都是Symbol函数的返回值，而且参数相同，但是它们是不相等的。</p>
<p>Symbol 值不能与其他类型的值进行运算，会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sym = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;My symbol&#x27;</span>);<br><br><span class="hljs-string">&quot;your symbol is &quot;</span> + sym<br><span class="hljs-comment">// TypeError: can&#x27;t convert symbol to string</span><br><span class="hljs-string">`your symbol is <span class="hljs-subst">$&#123;sym&#125;</span>`</span><br><span class="hljs-comment">// TypeError: can&#x27;t convert symbol to string</span><br></code></pre></td></tr></table></figure>
<p>但是，Symbol 值可以显式转为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sym = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;My symbol&#x27;</span>);<br><br><span class="hljs-title class_">String</span>(sym) <span class="hljs-comment">// &#x27;Symbol(My symbol)&#x27;</span><br>sym.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &#x27;Symbol(My symbol)&#x27;</span><br></code></pre></td></tr></table></figure>
<p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sym = <span class="hljs-title class_">Symbol</span>();<br><span class="hljs-title class_">Boolean</span>(sym) <span class="hljs-comment">// true</span><br>!sym  <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">if</span> (sym) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-title class_">Number</span>(sym) <span class="hljs-comment">// TypeError</span><br>sym + <span class="hljs-number">2</span> <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure>
<h2 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h2><p>创建 Symbol 的时候，可以添加一个描述。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sym = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <br></code></pre></td></tr></table></figure>
<p>上面代码中，sym的描述就是字符串foo。<br>但是，读取这个描述需要将 Symbol 显式转为字符串，即下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sym = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <br><br><span class="hljs-title class_">String</span>(sym) <span class="hljs-comment">// &quot;Symbol(foo)&quot; </span><br>sym.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &quot;Symbol(foo)&quot; </span><br></code></pre></td></tr></table></figure>
<p>上面的用法不是很方便。<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-Symbol-description">ES2019</a> 提供了一个实例属性description，直接返回 Symbol 的描述。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sym = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <br><br>sym.<span class="hljs-property">description</span> <span class="hljs-comment">// &quot;foo&quot; </span><br></code></pre></td></tr></table></figure>
<h2 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h2><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> mySymbol = <span class="hljs-title class_">Symbol</span>();<br><br><span class="hljs-comment">// 第一种写法</span><br><span class="hljs-keyword">let</span> a = &#123;&#125;;<br>a[mySymbol] = <span class="hljs-string">&#x27;Hello!&#x27;</span>;<br><br><span class="hljs-comment">// 第二种写法</span><br><span class="hljs-keyword">let</span> a = &#123;<br>  [mySymbol]: <span class="hljs-string">&#x27;Hello!&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 第三种写法</span><br><span class="hljs-keyword">let</span> a = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(a, mySymbol, &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Hello!&#x27;</span> &#125;);<br><br><span class="hljs-comment">// 以上写法都得到同样结果</span><br>a[mySymbol] <span class="hljs-comment">// &quot;Hello!&quot;</span><br></code></pre></td></tr></table></figure>
<p>上面代码通过方括号结构和Object.defineProperty，将对象的属性名指定为一个 Symbol 值。<br>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mySymbol = <span class="hljs-title class_">Symbol</span>();<br><span class="hljs-keyword">const</span> a = &#123;&#125;;<br><br>a.<span class="hljs-property">mySymbol</span> = <span class="hljs-string">&#x27;Hello!&#x27;</span>;<br>a[mySymbol] <span class="hljs-comment">// undefined</span><br>a[<span class="hljs-string">&#x27;mySymbol&#x27;</span>] <span class="hljs-comment">// &quot;Hello!&quot;</span><br></code></pre></td></tr></table></figure>
<p>上面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。<br>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-title class_">Symbol</span>();<br><br><span class="hljs-keyword">let</span> obj = &#123;<br>  [s]: <span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) &#123; ... &#125;<br>&#125;;<br><br>obj[s](<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure>
<p>上面代码中，如果s不放在方括号中，该属性的键名就是字符串s，而不是s所代表的那个 Symbol 值。<br>采用增强的对象写法，上面代码的obj对象可以写得更简洁一些。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  [s](arg) &#123; ... &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p> Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> log = &#123;&#125;;<br><br>log.<span class="hljs-property">levels</span> = &#123;<br>  <span class="hljs-attr">DEBUG</span>: <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;debug&#x27;</span>),<br>  <span class="hljs-attr">INFO</span>: <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;info&#x27;</span>),<br>  <span class="hljs-attr">WARN</span>: <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;warn&#x27;</span>)<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(log.<span class="hljs-property">levels</span>.<span class="hljs-property">DEBUG</span>, <span class="hljs-string">&#x27;debug message&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(log.<span class="hljs-property">levels</span>.<span class="hljs-property">INFO</span>, <span class="hljs-string">&#x27;info message&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p> 常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的switch语句会按设计的方式工作。<br>还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p>
<h2 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h2><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。<br>但是，它也不是私有属性，有一个Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">let</span> a = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-keyword">let</span> b = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;b&#x27;</span>);<br><br>obj[a] = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br>obj[b] = <span class="hljs-string">&#x27;World&#x27;</span>;<br><br><span class="hljs-keyword">const</span> objectSymbols = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj);<br><br>objectSymbols<br><span class="hljs-comment">// [Symbol(a), Symbol(b)]</span><br></code></pre></td></tr></table></figure>
<p>上面代码是Object.getOwnPropertySymbols()方法的示例，可以获取所有 Symbol 属性名。<br>下面是另一个例子，Object.getOwnPropertySymbols()方法与for…in循环、Object.getOwnPropertyNames方法进行对比的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> foo = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><br>obj[foo] = <span class="hljs-string">&#x27;bar&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// 无输出</span><br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(obj) <span class="hljs-comment">// []</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj) <span class="hljs-comment">// [Symbol(foo)]</span><br></code></pre></td></tr></table></figure>
<p>上面代码中，使用for…in循环和Object.getOwnPropertyNames()方法都得不到 Symbol 键名，需要使用Object.getOwnPropertySymbols()方法。<br>另一个新的 API，Reflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;my_key&#x27;</span>)]: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">enum</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">nonEnum</span>: <span class="hljs-number">3</span><br>&#125;;<br><br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj)<br><span class="hljs-comment">//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</span><br></code></pre></td></tr></table></figure>
<p>由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> size = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;size&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Collection</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>[size] = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">item</span>) &#123;<br>    <span class="hljs-variable language_">this</span>[<span class="hljs-variable language_">this</span>[size]] = item;<br>    <span class="hljs-variable language_">this</span>[size]++;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">sizeOf</span>(<span class="hljs-params">instance</span>) &#123;<br>    <span class="hljs-keyword">return</span> instance[size];<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Collection</span>();<br><span class="hljs-title class_">Collection</span>.<span class="hljs-title function_">sizeOf</span>(x) <span class="hljs-comment">// 0</span><br><br>x.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-title class_">Collection</span>.<span class="hljs-title function_">sizeOf</span>(x) <span class="hljs-comment">// 1</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(x) <span class="hljs-comment">// [&#x27;0&#x27;]</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(x) <span class="hljs-comment">// [&#x27;0&#x27;]</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(x) <span class="hljs-comment">// [Symbol(size)]</span><br></code></pre></td></tr></table></figure>
<p>上面代码中，对象x的size属性是一个 Symbol 值，所以Object.keys(x)、Object.getOwnPropertyNames(x)都无法获取它。这就造成了一种非私有的内部方法的效果。</p>
<h2 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h2><p>有时，我们希望重新使用同一个 Symbol 值，Symbol.for()方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><br>s1 === s2 <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>上面代码中，s1和s2都是 Symbol 值，但是它们都是由同样参数的Symbol.for方法生成的，所以实际上是同一个值。<br>Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(“cat”)30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(“cat”)30 次，会返回 30 个不同的 Symbol 值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;bar&quot;</span>) === <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;bar&quot;</span>)<br><span class="hljs-comment">// true</span><br><br><span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;bar&quot;</span>) === <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;bar&quot;</span>)<br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
<p>上面代码中，由于Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。<br>Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br><span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(s1) <span class="hljs-comment">// &quot;foo&quot;</span><br><br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br><span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(s2) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>
<p>上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。<br>注意，Symbol.for()为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> x = <span class="hljs-title function_">foo</span>();<br><span class="hljs-keyword">const</span> y = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x === y); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>上面代码中，Symbol.for(‘bar’)是函数内部运行的，但是生成的 Symbol 值是登记在全局环境的。所以，第二次运行Symbol.for(‘bar’)可以取到这个 Symbol 值。<br>Symbol.for()的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);<br>iframe.<span class="hljs-property">src</span> = <span class="hljs-title class_">String</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(iframe);<br><br>iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>) === <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<h2 id="内置的-Symbol-值"><a href="#内置的-Symbol-值" class="headerlink" title="内置的 Symbol 值"></a>内置的 Symbol 值</h2><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p>
<h3 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h3><p>对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是Foo<a href="foo">Symbol.hasInstance</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>](foo) &#123;<br>    <span class="hljs-keyword">return</span> foo <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>;<br>  &#125;<br>&#125;<br><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>() <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>上面代码中，MyClass是一个类，new MyClass()会返回一个实例。该实例的Symbol.hasInstance方法，会在进行instanceof运算时自动调用，判断左侧的运算子是否为Array的实例。<br>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Even</span> &#123;<br>  <span class="hljs-keyword">static</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>](obj) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Number</span>(obj) % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Even</span> = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>](obj) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Number</span>(obj) % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-number">1</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Even</span> <span class="hljs-comment">// false</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Even</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">12345</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Even</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
<h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h3><p>对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>];<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].<span class="hljs-title function_">concat</span>(arr1, <span class="hljs-string">&#x27;e&#x27;</span>) <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br>arr1[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>] <span class="hljs-comment">// undefined</span><br><br><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>];<br>arr2[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>] = <span class="hljs-literal">false</span>;<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].<span class="hljs-title function_">concat</span>(arr2, <span class="hljs-string">&#x27;e&#x27;</span>) <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;c&#x27;,&#x27;d&#x27;], &#x27;e&#x27;]</span><br></code></pre></td></tr></table></figure>
<p>上面代码说明，数组的默认行为是可以展开，Symbol.isConcatSpreadable默认等于undefined。该属性等于true时，也有展开的效果。<br>类似数组的对象正好相反，默认不展开。它的Symbol.isConcatSpreadable属性设为true，才可以展开。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">length</span>: <span class="hljs-number">2</span>, <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;d&#x27;</span>&#125;;<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].<span class="hljs-title function_">concat</span>(obj, <span class="hljs-string">&#x27;e&#x27;</span>) <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, obj, &#x27;e&#x27;]</span><br><br>obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>] = <span class="hljs-literal">true</span>;<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].<span class="hljs-title function_">concat</span>(obj, <span class="hljs-string">&#x27;e&#x27;</span>) <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br></code></pre></td></tr></table></figure>
<p>Symbol.isConcatSpreadable属性也可以定义在类里面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">args</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(args);<br>    <span class="hljs-variable language_">this</span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>] = <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">args</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(args);<br>  &#125;<br>  get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>] () &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A1</span>();<br>a1[<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>;<br>a1[<span class="hljs-number">1</span>] = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">let</span> a2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A2</span>();<br>a2[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;<br>a2[<span class="hljs-number">1</span>] = <span class="hljs-number">6</span>;<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">concat</span>(a1).<span class="hljs-title function_">concat</span>(a2)<br><span class="hljs-comment">// [1, 2, 3, 4, [5, 6]]</span><br></code></pre></td></tr></table></figure>
<p>上面代码中，类A1是可展开的，类A2是不可展开的，所以使用concat时有不一样的结果。<br>注意，Symbol.isConcatSpreadable的位置差异，A1是定义在实例上，A2是定义在类本身，效果相同。</p>
<h3 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h3><p>对象的Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">const</span> b = a.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x);<br><span class="hljs-keyword">const</span> c = a.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">1</span>);<br><br>b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-comment">// true</span><br>c <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>上面代码中，子类MyArray继承了父类Array，a是MyArray的实例，b和c是a的衍生对象。你可能会认为，b和c都是调用数组方法生成的，所以应该是数组（Array的实例），但实际上它们也是MyArray的实例。<br>Symbol.species属性就是为了解决这个问题而提供的。现在，我们可以为MyArray设置Symbol.species属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;<br>  <span class="hljs-keyword">static</span> get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">species</span>]() &#123; <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面代码中，由于定义了Symbol.species属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义Symbol.species属性要采用get取值器。默认的Symbol.species属性等同于下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">species</span>]() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在，再来看前面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;<br>  <span class="hljs-keyword">static</span> get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">species</span>]() &#123; <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>();<br><span class="hljs-keyword">const</span> b = a.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x);<br><br>b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-comment">// false</span><br>b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>上面代码中，a.map(x &#x3D;&gt; x)生成的衍生对象，就不是MyArray的实例，而直接就是Array的实例。<br>再看一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Promise</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Promise</span> &#123;<br>  <span class="hljs-keyword">static</span> get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">species</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title function_">T1</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-title function_">r</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v) <span class="hljs-keyword">instanceof</span> <span class="hljs-variable constant_">T1</span> <span class="hljs-comment">// true</span><br><span class="hljs-keyword">new</span> <span class="hljs-title function_">T2</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-title function_">r</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v) <span class="hljs-keyword">instanceof</span> <span class="hljs-variable constant_">T2</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
<p>上面代码中，T2定义了Symbol.species属性，T1没有。结果就导致了创建衍生对象时（then方法），T1调用的是自身的构造方法，而T2调用的是Promise的构造方法。<br>总之，Symbol.species的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。</p>
<h3 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a>Symbol.match</h3><p>对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">match</span>(regexp)<br><span class="hljs-comment">// 等同于</span><br>regexp[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">match</span>](<span class="hljs-variable language_">this</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMatcher</span> &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">match</span>](string) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span>.<span class="hljs-title function_">indexOf</span>(string);<br>  &#125;<br>&#125;<br><br><span class="hljs-string">&#x27;e&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyMatcher</span>()) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
<h3 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a>Symbol.replace</h3><p>对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">replace</span>(searchValue, replaceValue)<br><span class="hljs-comment">// 等同于</span><br>searchValue[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">replace</span>](<span class="hljs-variable language_">this</span>, replaceValue)<br></code></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> x = &#123;&#125;;<br>x[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">replace</span>] = <span class="hljs-function">(<span class="hljs-params">...s</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<br><br><span class="hljs-string">&#x27;Hello&#x27;</span>.<span class="hljs-title function_">replace</span>(x, <span class="hljs-string">&#x27;World&#x27;</span>) <span class="hljs-comment">// [&quot;Hello&quot;, &quot;World&quot;]</span><br></code></pre></td></tr></table></figure>
<p>Symbol.replace方法会收到两个参数，第一个参数是replace方法正在作用的对象，上面例子是Hello，第二个参数是替换后的值，上面例子是World。</p>
<h3 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a>Symbol.search</h3><p>对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">search</span>(regexp)<br><span class="hljs-comment">// 等同于</span><br>regexp[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">search</span>](<span class="hljs-variable language_">this</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySearch</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>  &#125;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">search</span>](string) &#123;<br>    <span class="hljs-keyword">return</span> string.<span class="hljs-title function_">indexOf</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>  &#125;<br>&#125;<br><span class="hljs-string">&#x27;foobar&#x27;</span>.<span class="hljs-title function_">search</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MySearch</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)) <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure>
<h3 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a>Symbol.split</h3><p>对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">split</span>(separator, limit)<br><span class="hljs-comment">// 等同于</span><br>separator[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">split</span>](<span class="hljs-variable language_">this</span>, limit)<br></code></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySplitter</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>  &#125;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">split</span>](string) &#123;<br>    <span class="hljs-keyword">let</span> index = string.<span class="hljs-title function_">indexOf</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>    <span class="hljs-keyword">if</span> (index === -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> string;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [<br>      string.<span class="hljs-title function_">substr</span>(<span class="hljs-number">0</span>, index),<br>      string.<span class="hljs-title function_">substr</span>(index + <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>.<span class="hljs-property">length</span>)<br>    ];<br>  &#125;<br>&#125;<br><br><span class="hljs-string">&#x27;foobar&#x27;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MySplitter</span>(<span class="hljs-string">&#x27;foo&#x27;</span>))<br><span class="hljs-comment">// [&#x27;&#x27;, &#x27;bar&#x27;]</span><br><br><span class="hljs-string">&#x27;foobar&#x27;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MySplitter</span>(<span class="hljs-string">&#x27;bar&#x27;</span>))<br><span class="hljs-comment">// [&#x27;foo&#x27;, &#x27;&#x27;]</span><br><br><span class="hljs-string">&#x27;foobar&#x27;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MySplitter</span>(<span class="hljs-string">&#x27;baz&#x27;</span>))<br><span class="hljs-comment">// &#x27;foobar&#x27;</span><br></code></pre></td></tr></table></figure>
<p>上面方法使用Symbol.split方法，重新定义了字符串对象的split方法的行为，</p>
<h3 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h3><p>对象的Symbol.iterator属性，指向该对象的默认遍历器方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myIterable = &#123;&#125;;<br>myIterable[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-keyword">function</span>* () &#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>&#125;;<br><br>[...myIterable] <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>
<p>对象进行for…of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for…of 循环》一章。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Collection</span> &#123;<br>  *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-variable language_">this</span>[i] !== <span class="hljs-literal">undefined</span>) &#123;<br>      <span class="hljs-keyword">yield</span> <span class="hljs-variable language_">this</span>[i];<br>      ++i;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> myCollection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Collection</span>();<br>myCollection[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>myCollection[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> myCollection) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>
<h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h3><p>对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。<br>Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p>
<ul>
<li>Number：该场合需要转成数值</li>
<li>String：该场合需要转成字符串</li>
<li>Default：该场合可以转成数值，也可以转成字符串<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>](hint) &#123;<br>    <span class="hljs-keyword">switch</span> (hint) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;number&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;string&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;str&#x27;</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;default&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;default&#x27;</span>;<br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>     &#125;<br>   &#125;<br>&#125;;<br><br><span class="hljs-number">2</span> * obj <span class="hljs-comment">// 246</span><br><span class="hljs-number">3</span> + obj <span class="hljs-comment">// &#x27;3default&#x27;</span><br>obj == <span class="hljs-string">&#x27;default&#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-title class_">String</span>(obj) <span class="hljs-comment">// &#x27;str&#x27;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h3><p>对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例一</span><br>(&#123;[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]: <span class="hljs-string">&#x27;Foo&#x27;</span>&#125;.<span class="hljs-title function_">toString</span>())<br><span class="hljs-comment">// &quot;[object Foo]&quot;</span><br><br><span class="hljs-comment">// 例二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Collection</span> &#123;<br>  get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;xxx&#x27;</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Collection</span>();<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(x) <span class="hljs-comment">// &quot;[object xxx]&quot;</span><br></code></pre></td></tr></table></figure>
<p>ES6 新增内置对象的Symbol.toStringTag属性值如下。</p>
<ul>
<li>JSON[Symbol.toStringTag]：’JSON’</li>
<li>Math[Symbol.toStringTag]：’Math’</li>
<li>Module 对象M[Symbol.toStringTag]：’Module’</li>
<li>ArrayBuffer.prototype[Symbol.toStringTag]：’ArrayBuffer’</li>
<li>DataView.prototype[Symbol.toStringTag]：’DataView’</li>
<li>Map.prototype[Symbol.toStringTag]：’Map’</li>
<li>Promise.prototype[Symbol.toStringTag]：’Promise’</li>
<li>Set.prototype[Symbol.toStringTag]：’Set’</li>
<li>%TypedArray%.prototype[Symbol.toStringTag]：’Uint8Array’等</li>
<li>WeakMap.prototype[Symbol.toStringTag]：’WeakMap’</li>
<li>WeakSet.prototype[Symbol.toStringTag]：’WeakSet’</li>
<li>%MapIteratorPrototype%[Symbol.toStringTag]：’Map Iterator’</li>
<li>%SetIteratorPrototype%[Symbol.toStringTag]：’Set Iterator’</li>
<li>%StringIteratorPrototype%[Symbol.toStringTag]：’String Iterator’</li>
<li>Symbol.prototype[Symbol.toStringTag]：’Symbol’</li>
<li>Generator.prototype[Symbol.toStringTag]：’Generator’</li>
<li>GeneratorFunction.prototype[Symbol.toStringTag]：’GeneratorFunction’</li>
</ul>
<h3 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h3><p>对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">unscopables</span>]<br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//   copyWithin: true,</span><br><span class="hljs-comment">//   entries: true,</span><br><span class="hljs-comment">//   fill: true,</span><br><span class="hljs-comment">//   find: true,</span><br><span class="hljs-comment">//   findIndex: true,</span><br><span class="hljs-comment">//   includes: true,</span><br><span class="hljs-comment">//   keys: true</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">unscopables</span>])<br><span class="hljs-comment">// [&#x27;copyWithin&#x27;, &#x27;entries&#x27;, &#x27;fill&#x27;, &#x27;find&#x27;, &#x27;findIndex&#x27;, &#x27;includes&#x27;, &#x27;keys&#x27;]</span><br></code></pre></td></tr></table></figure>
<p>上面代码说明，数组有 7 个属性，会被with命令排除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 没有 unscopables 时</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; &#125;;<br><br><span class="hljs-keyword">with</span> (<span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) &#123;<br>  <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 1</span><br>&#125;<br><br><span class="hljs-comment">// 有 unscopables 时</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br>  get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">unscopables</span>]() &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span> &#125;;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; &#125;;<br><br><span class="hljs-keyword">with</span> (<span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) &#123;<br>  <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面代码通过指定Symbol.unscopables属性，使得with语法块不会在当前作用域寻找foo属性，即foo将指向外层作用域的变量。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/symbol">https://es6.ruanyifeng.com/#docs/symbol</a></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/blog/categories/JavaScript/" class="category-chain-item">JavaScript</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/blog/tags/JavaScript/">#JavaScript</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JavaScript-Symbol</div>
      <div>https://web.hanmingda.top.com/blog/2022/08/03/JS/Symbol/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Colin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年8月3日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2022/08/03/JS/ES6/" title="JavaScript-ES6">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JavaScript-ES6</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2022/08/03/JS/Object/" title="JavaScript-Object">
                        <span class="hidden-mobile">JavaScript-Object</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div>Design By Colin</div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/blog/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/blog/js/leancloud.js" ></script>

  <script  src="/blog/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/blog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
